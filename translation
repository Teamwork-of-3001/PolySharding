摘要
今天的区块链并没有真正意义上的规模化。随着更多的节点加入系统，系统的效率(计算、通信和存储)下降，或者最多保持不变。
实现区块链高效伸缩的一个主要思想是分片的概念:不同的节点子集处理区块链的不同部分，从而减少每个节点的负载。
然而，现有的分片建议通过在信任上妥协来实现效率伸缩——损坏给定分片中的节点将导致相应部分数据的永久丢失。
我们观察到分片类似于复制编码，而复制编码在编码理论中是低效和脆弱的。本文介绍了一种用于区块链编码存储和计算的新协议。
特别是，我们提出了PolyShard:“多项式编码分片”方案，该方案在存储效率、系统吞吐量和可靠性方面达到信息理论的上限，从而实现真正可伸缩的系统。
我们提供了仿真结果，数字演示了性能改进的现状，以及多碎片系统的可扩展性。最后，我们讨论了潜在的增强，并强调了构建这样一个系统时的实际考虑因素。

I.介绍
区块链系统维护分布式受信任分类账，可以进行有限状态计算，可以在无信任设置下执行大量程序。这为数字加密货币[1]、工业物联网[2]、医疗保健管理[3]等
多个领域带来了新的、令人兴奋的应用前景。然而，为了支持这些应用程序，我们需要能够与参与节点[4]的数量良好伸缩的区块链系统。可伸缩性是对
三个重要性能指标:测量吞吐量,随着交易数量的验证在不同的时间,存储效率——测量的最大大小blockchain可以由节点与固定存储大小,和安全——测量系统
可以容忍恶意节点的数量。所谓可伸缩，我们指的是所有这三个指标应随着节点数量N的增加而提高;这是一个非常高的期望——最先进的缩放解决方案[5]——[9]
期望性能指标不 会随着节点N的增加而变得更糟(最好)。

可扩展性一直是当前区块链系统面临的最大挑战之一，如比特币[1]和以太坊[10]。例如，比特币目前将其块大小限制为1mb，处理速率为7个交易/秒[11]，
本质上限制了吞吐量。阻碍这些传统技术扩展的主要原因是它们的关键支撑存储和计算方法涉及到完全复制:每个网络节点存储整个区块链并复制所有计算(验证)。

该特性提供了一个完整的复制系统，具有很高的安全性(能够容忍49%的敌对节点)。但是系统的存储效率和吞吐量受到了损害:无论网络大小如何，它们都保持不变。
在实践中，计算负担甚至随着节点数量的增加而增加(例如，随着时间的推移和更多用户的参与，挖掘谜题变得更加困难)，从而导致吞吐量下降。
但是，从信息理论的角度来看，这种权衡并不是最优的。给定N个网络节点的N个计算量和N个存储资源，则信息理论上界为:
 
很明显，这些边界可以由一个集中的系统同时实现，从而允许所有3个度量标准进行伸缩。如果一个精心设计的分散系统能够提供同样的可扩展性，
这将代表着对区块链的完全复制和真正可扩展性的一个重大进步——随着更多的节点参与到系统中，全面的性能会得到改善。这就是本文的研究目标。

为了缩小这一差距，区块链文献中讨论的主要解决方案是通过对[7]-[9]进行切分。关键思想是将区块链(或“碎片”)分解为片段，然后进行复制。
通过这种方式，存储和计算需求都减少了一个因子，该因子等于碎片k的数量。但是，为了让存储和吞吐量随N线性伸缩，参与碎片的节点数量q=N/K必须保持不变。
因此，攻击者仅需要控制少于q⁄2个节点来破坏碎片，产生q⁄2的安全级别，其随着N的增加而接近零。尽管已经做出各种努力来缓解这种安全问题（例如，
通过周期性地改组节点[8]），它们仍然容易受到强大的攻击者的攻击（例如，谁可以在改组后破坏节点），但没有一个能够实现安全可扩展性。 

总之，基于完全复制和分片的区块链系统都在吞吐量的可伸缩性、存储效率和安全性之间进行了权衡。因此，一个广泛开放的基本问题是：
有没有一种区块链设计可以同时提高存储效率、安全性和吞吐量?

本文通过引入编码分片的概念，肯定地回答了这个问题。特别地，我们提出了PolyShard(多项式编码分片)，这是一种通过Θ(N)同时缩放吞吐量、
存储效率和安全性的方案。(表1)
表一：提出的PolyShard验证方案与其他基准和信息理论限制的性能比较。 

PolyShard的灵感来自于编码计算[12]-[20]的最新发展，特别是拉格朗日编码计算[20]，它提供了一个转换框架，以非传统的编码形式注入计算冗余，
以处理分布式计算中的故障和错误。PolyShard背后的关键思想是，与传统的存储和处理单个未编码的shard不同，每个节点存储和计算的是相同大小的已编码的shard，
它是由使用著名的拉格朗日多项式的未编码碎片线性混合生成的。这种编码提供了计算冗余，同时提供了对恶意节点错误结果的安全性，
这是由噪声多项式插值技术(如Reed-Solomon解码)支持的。图1对比了区块链中的Polyshard、sharding和regular storage方法。黑圈对应节点，
上面显示存储的区块链。第二行不同的颜色对应不同的碎片，Polyshard混合碎片(颜色)。

虽然编码通常适用于许多分布式计算场景，但是以下两个显著特性使得PolyShard特别适合于区块链系统。
（1）无关性：用于生成编码碎片的编码策略忽略了验证函数。这意味着，相同的编码数据可以同时用于多个验证项目(例如:数字签名验证和支付系统中的余额验证)；
（2）增量式：PolyShard允许每个节点通过在最新的验证块上编码来扩展其本地编码shard，而不需要访问以前的块。这有助于在链增长时保持恒定的编码开销。
为了验证这一概念，我们模拟了一个支付区块链系统，该系统记录了所有客户之间的余额转移，并通过与之前验证过的块的总和进行比较来验证新的块。
我们在这个系统上进行各种网络大小和链长组合的实验，并测量/评估通过完全复制、未编码分片和多分片方案实现的吞吐量、存储和安全性。
从图2所示的测量结果可以看出，PolyShard确实实现了以网络大小作为未编码分片方案的吞吐量伸缩，比完全复制方案有了显著的改进。
这些实验验证了多碎片在同时提高存储效率、安全性和吞吐量方面的理论保证。
 
下面，我们列出本文的主要贡献。
（1）利用信息和编码理论的原理，我们提出了一种完全不同的可伸缩设计方法，称为编码分片。
（2）我们提出了一个通用编码分片原理的实例，称为PolyShard，它代表基于拉格朗日多项式的编码分片。
（3）我们证明了PolyShard在效率(吞吐量和存储)和安全性方面都提供了Θ(N)可伸缩性；
（4）通过对一个支付区块链系统的仿真和评价，验证了我们的理论研究结果。在该系统中实现了多碎片化，并对其有效性和安全性进行了数值验证。

相关的工作。分片是一种最先进的技术，用于对区块链系统[7]-[9]、[21]-[32]的计算、通信和存储进行缩放。关键思想是将整个区块链划分为K个碎片，
每个碎片由节点的一个不相交子集(矿工)管理。例如，在[7]中提出了一个sharding协议ELASTICO，其中传入的事务被分割成碎片，
每个碎片由一个并行的不相交节点委员会进行验证。基于ELASTICO的分布式分片协议OmniLedger[8]在多种途径上进行了改进，包括将节点分配到
具有更高安全保障的分片的新方法，提出了一种用于跨分片事务的原子协议，进一步优化了通信和存储设计。对于目前所有的分片系统，为了按节点数量N进行扩展，
分片K的数量需要随着N的增加而增加，即， K = O(N)。这导致每个碎片中的节点数量不变，这使得系统在网络扩展时更容易受到对手的攻击。
现有系统通过分片旋转[7]、[8]、[33]等系统解决方案实现安全。例如，OmniLedger利用RandHound[34](一种抗偏倚的分布式随机生成协议)对分配
给一个碎片的用户子集进行随机采样，并随时间随机更新这些子集。当对手节点在随机分配之前被固定时，这种方法可以提供近乎最优的安全性，
但当对手是动态的时，这种方法很容易受到影响，并且在分配给碎片后，这种方法可能会损坏节点。

II.问题公式：块验证
我们考虑一个由K个独立分片组成的区块链系统，每个客户端只关联到一个分片。为了表达的清晰，我们将重点放在可验证的分片内事务上;
交叉分片验证增加了复杂性，补充了本文的贡献;例如，[8]的原子支付和锁定机制可以很自然地与本文的思想结合起来。我们定义计算和网络模型，
然后在下面定义性能度量。

A.计算模型
每个分片k都维护自己的子链，k∈[1，k]。我们用t表示圆内的离散时间，Y_k(t)∈U表示圆t中分片k处的验证块，其中U是场F上的向量空间。
然后，将分片k到时间t-1的子链记为



IIIBaseline performance
    在本节中，我们首先给出了在信息论中任意区块链的三个性能指标的理论上界。然后我们研究了两种最先进的区块链方案的性能，并比较了与理论上限的差距。
在安全方面，不管是那种验证方案，网络中非诚实节点的数量的最大数目不能超过网络节点总数N的一半。因此安全性β ≤ N / 2 .
在存储方面，为了验证成功，链的大小不能超过N个节点的aggregated(总共；聚合)存储资源，否则链不能完全被存储，因此有γ ≤ N. 
最后，为了验证K个即将到来的区块，
验证函数f^t验证总次数必须至少超过K次。因此，系统吞吐量λ ≤ K/( K/N )= N.因此，在信息论中，安全性，存储效率，以及吞吐量上限都和网络大小N呈线性关系

全复制：就存储效率而言，由于每一个节点存储全部区块链的所有K个分片，全复制策略使得内存使用率γfull=1.由于每个全节点都会验证所有K个区块，
所以全复制方案的吞吐量为 λfull = K /(NKc(f^t)/(Nc(f^t)))=1.因此全复制方案不会随着网络大小变化而进行伸缩扩展。因为随着N增加，
存储和吞吐量都保持不变。
其优点是：只要恶意节点少于N/2，按照多数节点是好的节点的原则就会保证对每个区块进行正确的验证和更新。

未编码分片方案：在分片中，区块链由K个大小相等（大小q=N/K）的被称为分片的不相交子链组成。每组节点负责管理单个碎片，这是一个K’=1,N=q个节点的
全复制系统。由于每一个节点存储和验证单个分片，存储效率以及吞吐量分别为γsharding = K and λsharding = K /（N*c^t/(N*c^t)）= K.
这两个指标的大小与节点数量N呈现线性关系，因此K=Θ(N)是成立的。因此组大小q成为一个常数。所以，仅牺牲q/2个节点就会破坏一个一个碎片和链。
所以这个方案的安全关系数βsharding = q/2 = O(1)。尽管切分rotation（循环）等系统解决方案可以帮助实现线性伸缩的安全保证，
但它们只有在对手（非诚实节点）是非自适应的(或非常缓慢的自适应)时才是安全的。当对手是动态的，它可以在碎片分配完成后立即破坏属于一个特定碎片
的所有节点。在此模型下，安全性降低为常数。

    综上所述，无论是完全复制还是上述分片方案都不能同时提高存储效率、安全性、和吞吐量向信息论界限。我们注意到存储或
    分布式存储的代码不能在这里直接使用，因为我们需要能够在编码块上直接计算验证函数。这促使我们在下一节中提出PolyShard(多项式编码的分片)，
    以便同时实现这三个边界。为了清晰起见，从现在起，我们将把切分方案称为“未编码的分片”
IV：Main Results
理论1：对于一个包含多个分片的区块链系统，存在线性验证函数f^t,以及一些参数d,N,αβγμ,其中d是常数度，N是运行在网络中的节点数目，μ
指最多μ个部分是恶意的(0<μ<1/2).以下性能指标是可能同时实现的：
	γ=
	β=
	λ=
    对于验证函数c(f^t)= O(t)的计算复杂度。因此，理论上最优的信息存储效率、安全性和吞吐量可以在恒定的乘法间隔内同时实现。
上述性能指标由本文提出的编码验证方案PolyShard实现。为了证明定理1，我们将在下一节描述和分析PolyShard。
    备注1：使用PolyShard,每个节点在本地存储作为原始未编码碎片的线性组合生成的编码碎片。接收到新块后，每个节点使用相同的系数集线性组合它们，
创建一个编码块。然后，节点通过编码块及其本地存储计算验证函数。然后，节点通过编码块及其本地存储计算验证函数。计算结果被收集起来，
并使用Reed-Solomon解码对预期的验证结果进行解码。这种编码计算技术最初是在[20]中提出的用于计算存在计算错误的分布式多元多项式的编码计算技术，
其中拉格朗日多项式插值用于生成编码数据。
   备注2：与[20]静态数据一次计算的场景相比，随着更多的验证块被添加到链中，每个网络节点的本地存储在区块链系统中不断增长。动态更新与即将到来的
编码验证兼容的本地存储的需求对多碎片方案的设计提出了新的挑战。利用区块链的数据结构和编码策略的代数特性，我们提出了一种简单的增量存储更新策略，
用于需要访问最少数据量的多碎片。
   备注3：额外的编码开销，包括编码输入数据、解码验证结果和更新本地存储所需的操作数量，并不随子链的长度而伸缩。因此，多碎片的性能取决于
验证多项式f的模型，当计算f的成本随着t的增加而增加时，编码开销随着链的增长而变得微不足道。




VI 模拟结果
我们进行了详细的模拟，用以评估Polyshard在例1所述的支付区块链系统中的性能。该系统记录了客户端之间所有余额的转移，
并通过比较先前验证区块的总和（即：计算（1）中的验证函数）来验证新的区块。更具体地说，该系统包含K个分片，每个分片管理M个客户端。在每个时期t，
将一个交易块提交给每个分片k。我们分别使用完全复制法，未编码的分片和PolyShard方案在N个以上节点模拟该系统。
我们在不同的N和t值下测量每个方案的吞吐量，以了解其可扩展性。吞吐量定义为每个时间单位验证的区块数，并通过N个节点的平均验证时间
除以K（每个时期生成的区块数）测量。对于PolyShard，验证时间还包括每个节点花在编码区块上的时间。然而，由于编码时间是一个常数，
随着链变长，平衡求和时间随t增加，所以预期编码时间变得可以忽略不计。
我们注意到每个方案的存储效率和安全级别由系统参数决定，因此不需要测量。
我们用t = 1000个时期来模拟这个系统，使用不同数量的分片K∈[5,50]。每个分片管理M = 2000个客户端。我们固定比率N / K = 3。
因此，节点的数量是N∈[15,150]。我们在图4中绘制N，t，以及三种方案的吞吐量的全部关系。为了更仔细的观察，我们在图5中绘制
了当N = 150时t与吞吐量之间的关系，以及第I节图2中t = 1000时N与吞吐量之间的关系。
结果和讨论：
（1）吞吐量：正如预期的那样，PolyShard产生的吞吐量与未编码分片相同，大约是完全复制的K倍。从图5中，我们观察到所有三种方案的吞吐量
随着时间的增加而下降。这是因为随着每个分片上有更多的区块，验证一个块的计算复杂性也在增加。就可扩展性而言，图2表明PolyShard方案
和未编码分片两者的吞吐量随着网络规模N（和K）呈线性增加，而完全复制的吞吐量几乎保持不变。
（2）存储：很容易看出PolyShard与未编码的分片的存储增益超过完全复制，系数为K。因此，PolyShard和未编码的分片在存储中是可扩展的，
但完全复制不是（表IIa）。
（3）安全性：安全性：正如我们分析的那样，完全复制可以容忍高达50％的恶意节点，从而实现最高安全性级别。PolyShard的纠错过程为个
恶意节点提供了健壮性。相反，在未编码的分片下，每个分片仅由3个节点管理。因此，无论N如何，其安全级别仅为1，这是不可扩展的（表IIb）。
表格2：三种方案在不同网络规模N下的存储和安全性。
（a）存储效率
N	15	30	60	90	120	150
	1	1	1	1	1	1
	5	10	20	30	40	50
	5	10	20	30	40	50
（b）安全性
N	15	30	60	90	120	150
	7	15	30	45	60	75
	1	1	1	1	1	1
	5	10	20	30	40	50


  总之，PolyShard方案优于完全复制和未编码的分片方案，因为它是唯一可以同时满足1）减轻每个节点的存储负荷；
  2）通过扩展系统来提高验证吞吐量；3）即使攻击者的数量随着网络规模的增长而增加也不牺牲安全要求。

图4：三种方案在时间和节点数量方面的吞吐:

图5：当节点数N =150时，三种方案的吞吐量

VII 讨论
  在本节中，我们将讨论PolyShard如何适应当代区块链系统的整体架构。融入区块链系统中。我们注意到Polyshard到目前为止已经在一个简单的设置中进行
  了描述，其中每个分片在锁步中产生一个块。我们重点介绍了一个Polyshard如何融入现有区块链系统架构的实例，该系统结合了提案的标准分片方法，
  然后由Polyshard进行最终确定。通过用户分配算法将用户分配给各个分片来获得K个分片。使用标准分片系统将N个节点划分为K个分片（参见[8]）。
  在分片的内部，节点通过一个最终化的算法运行一个标准的区块链来获得一个区块在本地的最终版本。
  每个节点通过一个编码分片分配的算法分配编码分片，该算法将随机字段元素分配给节点，以便节点可以计算它将用于编码的线性组合。我们在这里指出，
  如果有限域F的大小远大于N，则通过这种方法很容易处理流失（用户加入和离开），这时，冲突的概率（两个用户被分配相同的字段元素） 变得可以忽略不计。
  因此，每个节点在未编码的分片和编码的分片中都起作用，因此其存储要求将加倍；但是，我们的系统仍然具有规模为N的存储效率。
  Polyshard算法现在在规定的时间间隔内从不同的分片中获取本地最终的块，并且它作为一个全局最后一步，在本地最终块的阶段执行编码验证。
  我们指出，需要高信任度的用户应在确认付款之前需要等待此全局最终确认的时间戳，而需要短延迟的用户可立即使用本地确认进行验证。
  除了上述问题之外，系统中可能存在跨链分片的交易，这些交易是支付记录或智能合约，其输入和输出分布在多个分片中。在这种情况下，
  我们将使用基于锁定的方法，该方法锁定源分片处的付款并为目标分片生成证书，以便可以花费这些金额；这个想法已经在Elastico [7]和Omniledger [8]中
  提出并实现。
与可验证计算的关系。在区块链中加速计算的一个替代范式是可验证的计算[39]--[43]，其中一个节点执行一组计算（例如，支付验证），
然后这些计算的完整性通过加密验证。我们的框架和可验证计算之间的一个主要区别是，我们的方案在针对计算无限的对手时，是信息理论安全，
而不是可验证计算方案提供的计算安全性。但是，可验证的计算方案可以提供零知识证明，而我们的方案不提供零知识能力。最后，可验证计算在非对称
环境中是相关的，在这种环境中，一台计算机要比其他计算机强大得多，这与Polyshard不同，Polyshard是为包含同等强大和分散节点的对称设置而设计的。
未来的研究方向。Polyshard目前使用的多项式的度数与节点数呈亚线性伸缩。未来工作的一个有趣方向是消除这种限制。特别是，
低深度运算线路的计算能够被低阶多项式反复执行。未来研究的另一个重要方向是设计可以表示为低阶多项式或低深度算术线路的验证方案。
VIII.致谢
  我们感谢分布技术研究基金会、IOHK、国家科学基金资助的CCF 1705007、CCF-1763673和CCF-1703575，以及陆军研究办公室资助的W911NF1810332。该
  资料还基于美国国防部高级研究计划局(DARPA)根据合同编号支持的工作。HR001117C0053。所表达的观点，意见或发现是作者的观点，
  不应被解释为代表国防部或美国政府的官方观点或政策。


