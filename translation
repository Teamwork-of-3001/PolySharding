摘要
今天的区块链并没有真正意义上的规模化。随着更多的节点加入系统，系统的效率(计算、通信和存储)下降，或者最多保持不变。
实现区块链高效伸缩的一个主要思想是分片的概念:不同的节点子集处理区块链的不同部分，从而减少每个节点的负载。
然而，现有的分片建议通过在信任上妥协来实现效率伸缩——损坏给定分片中的节点将导致相应部分数据的永久丢失。
我们观察到分片类似于复制编码，而复制编码在编码理论中是低效和脆弱的。本文介绍了一种用于区块链编码存储和计算的新协议。
特别是，我们提出了PolyShard:“多项式编码分片”方案，该方案在存储效率、系统吞吐量和可靠性方面达到信息理论的上限，从而实现真正可伸缩的系统。
我们提供了仿真结果，数字演示了性能改进的现状，以及多碎片系统的可扩展性。最后，我们讨论了潜在的增强，并强调了构建这样一个系统时的实际考虑因素。


IIIBaseline performance
在本节中，我们首先给出了在信息论中任意区块链的三个性能指标的理论上界。然后我们研究了两种最先进的区块链方案的性能，并比较了与理论上限的差距。
在安全方面，不管是那种验证方案，网络中非诚实节点的数量的最大数目不能超过网络节点总数N的一半。因此安全性β ≤ N / 2 .
在存储方面，为了验证成功，链的大小不能超过N个节点的aggregated(总共；聚合)存储资源，否则链不能完全被存储，因此有γ ≤ N. 
最后，为了验证K个即将到来的区块，
验证函数f^t验证总次数必须至少超过K次。因此，系统吞吐量λ ≤ K/( K/N )= N.因此，在信息论中，安全性，存储效率，以及吞吐量上限都和网络大小N呈线性关系


VI 模拟结果
我们进行了详细的模拟，用以评估Polyshard在例1所述的支付区块链系统中的性能。该系统记录了客户端之间所有余额的转移，并通过比较先前验证区块的总和（即：计算（1）中的验证函数）来验证新的区块。更具体地说，该系统包含K个分片，每个分片管理M个客户端。在每个时期t，将一个交易块提交给每个分片k。我们分别使用完全复制法，未编码的分片和PolyShard方案在N个以上节点模拟该系统。
我们在不同的N和t值下测量每个方案的吞吐量，以了解其可扩展性。吞吐量定义为每个时间单位验证的区块数，并通过N个节点的平均验证时间除以K（每个时期生成的区块数）测量。对于PolyShard，验证时间还包括每个节点花在编码区块上的时间。然而，由于编码时间是一个常数，随着链变长，平衡求和时间随t增加，所以预期编码时间变得可以忽略不计。
我们注意到每个方案的存储效率和安全级别由系统参数决定，因此不需要测量。
我们用t = 1000个时期来模拟这个系统，使用不同数量的分片K∈[5,50]。每个分片管理M = 2000个客户端。我们固定比率N / K = 3。因此，节点的数量是N∈[15,150]。我们在图4中绘制N，t，以及三种方案的吞吐量的全部关系。为了更仔细的观察，我们在图5中绘制了当N = 150时t与吞吐量之间的关系，以及第I节图2中t = 1000时N与吞吐量之间的关系。
结果和讨论：
（1）吞吐量：正如预期的那样，PolyShard产生的吞吐量与未编码分片相同，大约是完全复制的K倍。从图5中，我们观察到所有三种方案的吞吐量随着时间的增加而下降。这是因为随着每个分片上有更多的区块，验证一个块的计算复杂性也在增加。就可扩展性而言，图2表明PolyShard方案和未编码分片两者的吞吐量随着网络规模N（和K）呈线性增加，而完全复制的吞吐量几乎保持不变。
（2）存储：很容易看出PolyShard与未编码的分片的存储增益超过完全复制，系数为K。因此，PolyShard和未编码的分片在存储中是可扩展的，但完全复制不是（表IIa）。
（3）安全性：安全性：正如我们分析的那样，完全复制可以容忍高达50％的恶意节点，从而实现最高安全性级别。PolyShard的纠错过程为个恶意节点提供了健壮性。相反，在未编码的分片下，每个分片仅由3个节点管理。因此，无论N如何，其安全级别仅为1，这是不可扩展的（表IIb）。
表格2：三种方案在不同网络规模N下的存储和安全性。
（a）存储效率
N	15	30	60	90	120	150
	1	1	1	1	1	1
	5	10	20	30	40	50
	5	10	20	30	40	50
（b）安全性
N	15	30	60	90	120	150
	7	15	30	45	60	75
	1	1	1	1	1	1
	5	10	20	30	40	50


  总之，PolyShard方案优于完全复制和未编码的分片方案，因为它是唯一可以同时满足1）减轻每个节点的存储负荷；2）通过扩展系统来提高验证吞吐量；3）即使攻击者的数量随着网络规模的增长而增加也不牺牲安全要求。

图4：三种方案在时间和节点数量方面的吞吐:

图5：当节点数N =150时，三种方案的吞吐量

VII 讨论
  在本节中，我们将讨论PolyShard如何适应当代区块链系统的整体架构。融入区块链系统中。我们注意到Polyshard到目前为止已经在一个简单的设置中进行了描述，其中每个分片在锁步中产生一个块。我们重点介绍了一个Polyshard如何融入现有区块链系统架构的实例，该系统结合了提案的标准分片方法，然后由Polyshard进行最终确定。通过用户分配算法将用户分配给各个分片来获得K个分片。使用标准分片系统将N个节点划分为K个分片（参见[8]）。在分片的内部，节点通过一个最终化的算法运行一个标准的区块链来获得一个区块在本地的最终版本。
  每个节点通过一个编码分片分配的算法分配编码分片，该算法将随机字段元素分配给节点，以便节点可以计算它将用于编码的线性组合。我们在这里指出，如果有限域F的大小远大于N，则通过这种方法很容易处理流失（用户加入和离开），这时，冲突的概率（两个用户被分配相同的字段元素） 变得可以忽略不计。因此，每个节点在未编码的分片和编码的分片中都起作用，因此其存储要求将加倍；但是，我们的系统仍然具有规模为N的存储效率。Polyshard算法现在在规定的时间间隔内从不同的分片中获取本地最终的块，并且它作为一个全局最后一步，在本地最终块的阶段执行编码验证。我们指出，需要高信任度的用户应在确认付款之前需要等待此全局最终确认的时间戳，而需要短延迟的用户可立即使用本地确认进行验证。
  除了上述问题之外，系统中可能存在跨链分片的交易，这些交易是支付记录或智能合约，其输入和输出分布在多个分片中。在这种情况下，我们将使用基于锁定的方法，该方法锁定源分片处的付款并为目标分片生成证书，以便可以花费这些金额；这个想法已经在Elastico [7]和Omniledger [8]中提出并实现。
与可验证计算的关系。在区块链中加速计算的一个替代范式是可验证的计算[39]--[43]，其中一个节点执行一组计算（例如，支付验证），然后这些计算的完整性通过加密验证。我们的框架和可验证计算之间的一个主要区别是，我们的方案在针对计算无限的对手时，是信息理论安全，而不是可验证计算方案提供的计算安全性。但是，可验证的计算方案可以提供零知识证明，而我们的方案不提供零知识能力。最后，可验证计算在非对称环境中是相关的，在这种环境中，一台计算机要比其他计算机强大得多，这与Polyshard不同，Polyshard是为包含同等强大和分散节点的对称设置而设计的。
未来的研究方向。Polyshard目前使用的多项式的度数与节点数呈亚线性伸缩。未来工作的一个有趣方向是消除这种限制。特别是，低深度运算线路的计算能够被低阶多项式反复执行。未来研究的另一个重要方向是设计可以表示为低阶多项式或低深度算术线路的验证方案。
VIII.致谢
  我们感谢分布技术研究基金会、IOHK、国家科学基金资助的CCF 1705007、CCF-1763673和CCF-1703575，以及陆军研究办公室资助的W911NF1810332。该资料还基于美国国防部高级研究计划局(DARPA)根据合同编号支持的工作。HR001117C0053。所表达的观点，意见或发现是作者的观点，不应被解释为代表国防部或美国政府的官方观点或政策。


